<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<event size="2" name="data"/>
<event size="2" name="motors"/>
<constant value="0" name="S_WAIT_SYNC"/>


<!--node Tim sur DESKTOP-F4559ND - 12816-->
<node name="Tim sur DESKTOP-F4559ND - 12816" nodeId="{69a5dd2e-b18e-49d3-a13c-41b975684f51}"><![CDATA[
### VARIABLES DECLARATION ###
var running = 0
var counter = 0
var state
var intensityDiff
var code[] = [0,0,0,0]
var slow = 11

var capLeft
var capRight

### EVENT BUTTON FORWARD ###
onevent button.forward
# starts line tracking and waits for sync bit
if button.forward == 1 then
	running = 1
	state = S_WAIT_SYNC
end

### EVENT BUTTON CENTER ###
onevent button.center
#stops running and motors, turns LEDs off
if  button.center == 1 then
	running = 0
	motor.left.target = 0
	motor.right.target = 0
end

### EVENT PROXIMITY SENSORS (EVERY 100 ms => 10 Hz)###
onevent prox
#if the robot is running, steering and bar code reading are activated
#we use the prox.ground.delta[1] to steer, the ...[0] to check the bar code
if running == 1 then	### STEERING PART ###
	capLeft=prox.ground.delta[1]
	capRight=prox.ground.delta[0]
	
	intensityDiff = capRight-525
	#speed of robot is adjusted to keep around a gray mean value. If 
	#difference is too important, the robot spins until it finds the line
	#again. The steering is controled by the gray gradient of the trail.
	if abs(intensityDiff) < 170 then
		motor.left.target = 115+intensityDiff/8
		motor.right.target = 115-intensityDiff/8
	else
		motor.left.target = intensityDiff/4
		motor.right.target = -intensityDiff/4
	end
	
	if capLeft < 900 or counter > 0 then
		if  counter% slow == 0 then			
			code[counter/slow] = capRight
		end
		counter ++
		if  counter == 4*slow then
			counter = 0			
		end
	end

	
end]]></node>


</network>
