<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<event size="2" name="data"/>
<event size="2" name="motors"/>
<constant value="0" name="S_WAIT_SYNC"/>


<!--node Tim sur DESKTOP-F4559ND - 12816-->
<node name="Tim sur DESKTOP-F4559ND - 12816" nodeId="{69a5dd2e-b18e-49d3-a13c-41b975684f51}"><![CDATA[
### VARIABLES DECLARATION ###
var running = 0
var counter = 0
var state
var intensityDiff
var code[] = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
var slow = 1
var reset = 200
var i
var j
var codeMoy[] = [0,0,0,0]
var moy
var nb = 0
#0 noir 1 Gris 2 GrisClair 3 Blanc
var finalCode[] = [0,0,0,0]

var capLeft
var capRight

### EVENT BUTTON FORWARD ###
onevent button.forward
# starts line tracking and waits for sync bit
if button.forward == 1 then
	running = 1
	state = S_WAIT_SYNC
end

### EVENT BUTTON CENTER ###
onevent button.center
#stops running and motors, turns LEDs off
if  button.center == 1 then
	running = 0
	motor.left.target = 0
	motor.right.target = 0
end

### EVENT PROXIMITY SENSORS (EVERY 100 ms => 10 Hz)###
onevent prox
#if the robot is running, steering and bar code reading are activated
#we use the prox.ground.delta[1] to steer, the ...[0] to check the bar code
if running == 1 then	### STEERING PART ###
	capLeft=prox.ground.delta[1]
	capRight=prox.ground.delta[0]
	
	intensityDiff = capLeft-525
	#speed of robot is adjusted to keep around a gray mean value. If 
	#difference is too important, the robot spins until it finds the line
	#again. The steering is controled by the gray gradient of the trail.
	if abs(intensityDiff) < 170 then
		motor.left.target = 115-intensityDiff/8
		motor.right.target = 115+intensityDiff/8
	else
		motor.left.target = -intensityDiff/4
		motor.right.target = intensityDiff/4
	end
	if reset == 0 then
		if capRight < 905 or counter > 0 then
			if  counter% slow == 0 then			
				code[counter/slow] = capRight
			end
			counter ++
			if  counter == 24*slow then
				counter = 0
				reset = 50
				for i in 0:3 do
					moy = 0
					for j in 0:5 do
						moy = moy + code[i*6+j]
					end
					moy = moy/6
					codeMoy[nb] = moy				
					if moy<910 and moy>800 then#GC
						finalCode[nb] = 2
						nb = nb + 1
					elseif moy>910 then#BLANC
						finalCode[nb] = 3
						nb = nb + 1
					elseif code[i]<800 and code[i]>500 then#G
						finalCode[nb] = 1
						nb = nb + 1
					else#N
						finalCode[nb] = 0
						nb = nb + 1
					end
				end
			end
		end
	elseif reset == 1 then
		reset = reset - 1
		nb = 0
		code = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
		for i in 0:3 do
			finalCode[i] = 3
		end
	else
		reset = reset - 1
	end

	
end]]></node>


</network>
